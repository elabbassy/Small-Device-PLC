/* Small Device PLC
 * An SDCC (Small Device C Compiler) port for (MATIEC) implementaion of 
 * IEC 61131-3 standard.
 * based on "MATIEC lib c"  (See the license below)
 * the proting attempt is as follows:
 * 1- code part is stripped from header files, function prototypes
 *    was kept with a little modifications if nessessary.
 * 2- every individual function is written to a seperate file and linked to "lib"
 *    archive for the sake of SDCC Linker's code optimization.
 * 3- the current version of SDCC (4.4.0) dose not support: (a)Compound  
 *    literals, (b)’double’ precision floating point ('float' is used instead)
 *     and,(c)initialization of structure arrays.
 * 4- due to the limitations mentiond above:
 *    (a) DATE/TIME manuplation functions (ex: SUB_TIME, EQ_DATE, ...) were 
 *        changed to "STATIC" function type with (2) arguments (instead originally 
 *        variadic implementaion), this will lead to compile-time error 
 *        if more arguments passed.
 *    (b) "SFC" language is not supported yet.
 *    (c) explicitly casting for types (TIME, DATE, DT, DOT) generated by "iec2c"
 *        must be removed. (eg: by python script or shell commands)
 * 5- 'STRING' manuplation functions is not supported.
 * 6- most of functions are (reentrant) so, lib archive shall be compiled/linked with 
 *    "stack-auto" - for mcs51 target - or equivalent option.
 *
 * elabbassy2013@gmail.com
 * License: as below.
 */
/*
 * copyright 2008 Edouard TISSERANT
 * copyright 2011 Mario de Sousa (msousa@fe.up.pt)
 *
 * Offered to the public under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
 * General Public License for more details.
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */

/****
 * IEC 61131-3 standard function library
 */

/* NOTE: This file is full of (what may seem at first) very strange macros.
 *       If you want to know what all these strange macros are doing,
 *       just parse this file through a C preprocessor (e.g. cpp), 
 *       and analyse the output!
 *       $gcc -E iec_std_lib.h 
 */

#ifndef _IEC_STD_FUNCTIONS_H
#define _IEC_STD_FUNCTIONS_H


/*****************************************************************/
/*****************************************************************/
/*****                                                       *****/
/*****                 IEC 61131-3                           *****/
/*****      S T A N D A R D     F U N C T I O N S            *****/
/*****                                                       *****/
/*****************************************************************/
/*****************************************************************/

/* NOTE: If you want to know what all these strange macros are doing,
 *       just parse this file through a C preprocessor, and analyse the output!
 *       $gcc -E iec_std_lib.h 
 */

/* NOTE: We only define and declare the explicitly typed standard functions
 *       (e.g., SIN_REAL, SIN_LREAL, ..., ADD_SINT, ADD_INT, ADD_LINT, ...)
 *       We do not declare/define the overloaded functions
 *       (SIN, ADD, ...). 
 *       When handling a call to an overloaded function, the iec2c compiler 
 *       will determine in stage3 the data type of the parameter being passed, 
 *       and in stage4 generate the C code to call the correct
 *       typed standard function.
 */

/* NOTE on explicit typing of:
 *           - Table 25 - Standard bit shift functions
 *           - Table 29 - Character string Functions
 *
 *  In section 2.5.1.4 (Typing, overloading, and type conversion) of the IEC 61131-3 (version 2)
 *  of the standard, it is stated:
 * "A standard function, [...] is said to be overloaded when it
 * can operate on input data elements of various types within a generic type designator as defined in
 * 2.3.2. For instance, an overloaded addition function on generic type ANY_NUM can operate on data
 * of types LREAL, REAL, DINT, INT, and SINT."
 * [...]
 * "When a function which normally represents an overloaded operator is to be typed, i.e., the types
 * of its inputs and outputs restricted to a particular elementary or derived data type as defined in
 * 2.3, this shall be done by appending an "underline" character followed by the required type, as
 * shown in table 21."
 *
 * However, this explanation (as well as the example in table 21) only refers to functions where the same
 * generic data type is used for the single input and the output parameter.
 * How can we create explicitly types functions when this is not the case?
 * It does not seem to be covered by the standard.
 *
 * For this reason, we do not define the LEN_SINT, LEN_INT, LEN_STRING, LEN_[ANY_INT], LEN_[ANY_STRING] functions...
 */
 

/********************/
/*   EN/ENO PARAMS  */
/********************/

#ifdef DISABLE_EN_ENO_PARAMETERS

  /* Do _not_ generate the EN and ENO parameters! */
  #define EN_ENO_PARAMS
  #define EN_ENO

  #define TEST_EN(TYPENAME)
  #define TEST_EN_COND(TYPENAME, COND)

#else
    
  /* _Do_ generate the EN and ENO parameters! */
  #define EN_ENO_PARAMS BOOL EN, BOOL *ENO,
  #define EN_ENO EN, ENO,

  #define TEST_EN(TYPENAME)\
    if (!EN) {\
      if (ENO != NULL)\
        *ENO = __BOOL_LITERAL(FALSE);\
      return __INIT_##TYPENAME;\
    }\
    else if (ENO != NULL)\
      *ENO = __BOOL_LITERAL(TRUE);

  #define TEST_EN_COND(TYPENAME, COND)\
    if (!EN || (COND)) {\
      if (ENO != NULL)\
        *ENO = __BOOL_LITERAL(FALSE);\
      return __INIT_##TYPENAME;\
    }\
    else if (ENO != NULL)\
      *ENO = __BOOL_LITERAL(TRUE);
    
#endif
  
  
/*****************************************/  
/*****************************************/  
/*  2.5.1.5.1 Type Conversion Functions  */
/*****************************************/  
/*****************************************/  

#define __convert_type(from_TYPENAME,to_TYPENAME, oper) \
inline to_TYPENAME from_TYPENAME##_TO_##to_TYPENAME(EN_ENO_PARAMS from_TYPENAME op);

#define __convert_type_to_date_time(from_TYPENAME,to_TYPENAME, oper) \
inline to_TYPENAME* p##from_TYPENAME##_TO_##to_TYPENAME(EN_ENO_PARAMS from_TYPENAME op);

#define __convert_type_from_date_time(from_TYPENAME,to_TYPENAME, oper) \
inline to_TYPENAME p##from_TYPENAME##_TO_##to_TYPENAME(EN_ENO_PARAMS from_TYPENAME *op);

/******** [ANY_NUM | ANY_NBIT]_TO_BOOL   ************/
#define __convert_num_to_bool(TYPENAME) \
inline BOOL TYPENAME##_TO_BOOL(EN_ENO_PARAMS TYPENAME op);
__ANY_NUM(__convert_num_to_bool)
__ANY_NBIT(__convert_num_to_bool)

/******** [TIME | ANY_DATE]_TO_BOOL   ************/
#define __convert_time_to_bool(TYPENAME) \
 inline BOOL p##TYPENAME##_TO_BOOL(EN_ENO_PARAMS TYPENAME *op);
__convert_time_to_bool(TIME)
__ANY_DATE(__convert_time_to_bool)

#define DATE_TO_BOOL(EN,ENO,op) pDATE_TO_BOOL(EN,ENO,&(op))
#define TOD_TO_BOOL(EN,ENO,op) pTOD_TO_BOOL(EN,ENO,&(op))
#define DT_TO_BOOL(EN,ENO,op) pDT_TO_BOOL(EN,ENO,&(op))
#define TIME_TO_BOOL(EN,ENO,op) pTIME_TO_BOOL(EN,ENO,&(op))

#define __to_anynum_(from_TYPENAME)   __ANY_NUM_1(__iec_,from_TYPENAME)
#define __to_anyint_(from_TYPENAME)   __ANY_INT_1(__iec_,from_TYPENAME)
#define __to_anybit_(from_TYPENAME)   __ANY_BIT_1(__iec_,from_TYPENAME)
#define __to_anynbit_(from_TYPENAME) __ANY_NBIT_1(__iec_,from_TYPENAME)
#define __to_anysint_(from_TYPENAME) __ANY_SINT_1(__iec_,from_TYPENAME)
#define __to_anyuint_(from_TYPENAME) __ANY_UINT_1(__iec_,from_TYPENAME)
#define __to_anyreal_(from_TYPENAME) __ANY_REAL_1(__iec_,from_TYPENAME)
#define __to_anydate_(from_TYPENAME) __ANY_DATE_1(__iec_,from_TYPENAME)

/******** [ANY_BIT]_TO_[ANY_NUM | ANT_NBIT]   ************/
#define __iec_(to_TYPENAME,from_TYPENAME) __convert_type(from_TYPENAME, to_TYPENAME, __move_##to_TYPENAME)
__ANY_BIT(__to_anynum_)
__ANY_BIT(__to_anynbit_)
#undef __iec_

/******** [ANY_INT]_TO_[ANY_NUM | ANT_NBIT]   ************/
#define __iec_(to_TYPENAME,from_TYPENAME) __convert_type(from_TYPENAME, to_TYPENAME, __move_##to_TYPENAME)
__ANY_INT(__to_anynum_)
__ANY_INT(__to_anynbit_)
#undef __iec_

/******** [ANY_REAL]_TO_[ANY_NBIT]   ************/
#define __iec_(to_TYPENAME,from_TYPENAME) __convert_type(from_TYPENAME, to_TYPENAME, __real_to_bit)
__ANY_REAL(__to_anynbit_)
#undef __iec_

/******** [ANY_REAL]_TO_[ANY_NINT]   ************/
#define __iec_(to_TYPENAME,from_TYPENAME) __convert_type(from_TYPENAME, to_TYPENAME, __real_to_sint)
__ANY_REAL(__to_anysint_)
#undef __iec_
#define __iec_(to_TYPENAME,from_TYPENAME) __convert_type(from_TYPENAME, to_TYPENAME, __real_to_uint)
__ANY_REAL(__to_anyuint_)
#undef __iec_

/******** [ANY_REAL]_TO_[ANY_REAL]   ************/ 
#define __iec_(to_TYPENAME,from_TYPENAME) __convert_type(from_TYPENAME, to_TYPENAME, __move_##to_TYPENAME)
__ANY_REAL(__to_anyreal_)
#undef __iec_

/******** [ANY_BIT | ANY_INT]_TO_[TIME | ANY_DATE]   ************/ 
#define __iec_(from_TYPENAME) __convert_type_to_date_time(from_TYPENAME, TIME, __int_to_time)
__ANY_BIT(__iec_)
__ANY_INT(__iec_)
#undef __iec_

#define BYTE_TO_TIME *pBYTE_TO_TIME
#define WORD_TO_TIME *pWORD_TO_TIME
#define DWORD_TO_TIME *pDWORD_TO_TIME
#define LWORD_TO_TIME *pLWORD_TO_TIME
#define BOOL_TO_TIME *pBOOL_TO_TIME
#define SINT_TO_TIME *pSINT_TO_TIME
#define INT_TO_TIME *pINT_TO_TIME
#define DINT_TO_TIME *pDINT_TO_TIME
#define LINT_TO_TIME *pLINT_TO_TIME
#define USINT_TO_TIME *pUSINT_TO_TIME
#define UINT_TO_TIME *pUINT_TO_TIME
#define UDINT_TO_TIME *pUDINT_TO_TIME
#define ULINT_TO_TIME *pULINT_TO_TIME

#define __iec_(to_TYPENAME,from_TYPENAME) __convert_type_to_date_time(from_TYPENAME, to_TYPENAME, __int_to_time)
__ANY_BIT(__to_anydate_)
__ANY_INT(__to_anydate_)
#undef __iec_

#define BYTE_TO_DATE *pBYTE_TO_DATE
#define BYTE_TO_TOD *pBYTE_TO_TOD
#define BYTE_TO_DT *pBYTE_TO_DT
#define WORD_TO_DATE *pWORD_TO_DATE
#define WORD_TO_TOD *pWORD_TO_TOD
#define WORD_TO_DT *pWORD_TO_DT
#define DWORD_TO_DATE *pDWORD_TO_DATE
#define DWORD_TO_TOD *pDWORD_TO_TOD
#define DWORD_TO_DT *pDWORD_TO_DT
#define LWORD_TO_DATE *pLWORD_TO_DATE
#define LWORD_TO_TOD *pLWORD_TO_TOD
#define LWORD_TO_DT *pLWORD_TO_DT
#define BOOL_TO_DATE *pBOOL_TO_DATE
#define BOOL_TO_TOD *pBOOL_TO_TOD
#define BOOL_TO_DT *pBOOL_TO_DT
#define SINT_TO_DATE *pSINT_TO_DATE
#define SINT_TO_TOD *pSINT_TO_TOD
#define SINT_TO_DT *pSINT_TO_DT
#define INT_TO_DATE *pINT_TO_DATE
#define INT_TO_TOD *pINT_TO_TOD
#define INT_TO_DT *pINT_TO_DT
#define DINT_TO_DATE *pDINT_TO_DATE
#define DINT_TO_TOD *pDINT_TO_TOD
#define DINT_TO_DT *pDINT_TO_DT
#define LINT_TO_DATE *pLINT_TO_DATE
#define LINT_TO_TOD *pLINT_TO_TOD
#define LINT_TO_DT *pLINT_TO_DT
#define USINT_TO_DATE *pUSINT_TO_DATE
#define USINT_TO_TOD *pUSINT_TO_TOD
#define USINT_TO_DT *pUSINT_TO_DT
#define UINT_TO_DATE *pUINT_TO_DATE
#define UINT_TO_TOD *pUINT_TO_TOD
#define UINT_TO_DT *pUINT_TO_DT
#define UDINT_TO_DATE *pUDINT_TO_DATE
#define UDINT_TO_TOD *pUDINT_TO_TOD
#define UDINT_TO_DT *pUDINT_TO_DT
#define ULINT_TO_DATE *pULINT_TO_DATE
#define ULINT_TO_TOD *pULINT_TO_TOD
#define ULINT_TO_DT *pULINT_TO_DT

/******** [ANY_REAL]_TO_[TIME | ANY_DATE]   ************/ 
#define __iec_(from_TYPENAME) __convert_type_to_date_time(from_TYPENAME, TIME, __real_to_time)
__ANY_REAL(__iec_)
#undef __iec_

#define REAL_TO_TIME *pREAL_TO_TIME
#define LREAL_TO_TIME *pLREAL_TO_TIME

#define __iec_(to_TYPENAME,from_TYPENAME) __convert_type_to_date_time(from_TYPENAME, to_TYPENAME, __real_to_time)
__ANY_REAL(__to_anydate_)
#undef __iec_

#define REAL_TO_DATE *pREAL_TO_DATE
#define REAL_TO_TOD *pREAL_TO_TOD
#define REAL_TO_DT *pREAL_TO_DT
#define LREAL_TO_DATE *pLREAL_TO_DATE
#define LREAL_TO_TOD *pLREAL_TO_TOD
#define LREAL_TO_DT *pLREAL_TO_DT
/******** [TIME | ANY_DATE]_TO_[ANY_BIT | ANY_INT]   ************/ 
#define __iec_(to_TYPENAME,from_TYPENAME) __convert_type_from_date_time(from_TYPENAME, to_TYPENAME, __time_to_int)
__to_anyint_(TIME)
__to_anynbit_(TIME)
__ANY_DATE(__to_anyint_)
__ANY_DATE(__to_anynbit_)
#undef __iec_

#define TIME_TO_SINT(EN,ENO,op) pTIME_TO_SINT(EN,ENO,&(op))
#define TIME_TO_INT(EN,ENO,op) pTIME_TO_INT(EN,ENO,&(op))
#define TIME_TO_DINT(EN,ENO,op) pTIME_TO_DINT(EN,ENO,&(op))
#define TIME_TO_LINT(EN,ENO,op) pTIME_TO_LINT(EN,ENO,&(op))
#define TIME_TO_USINT(EN,ENO,op) pTIME_TO_USINT(EN,ENO,&(op))
#define TIME_TO_UINT(EN,ENO,op) pTIME_TO_UINT(EN,ENO,&(op))
#define TIME_TO_UDINT(EN,ENO,op) pTIME_TO_UDINT(EN,ENO,&(op))
#define TIME_TO_ULINT(EN,ENO,op) pTIME_TO_ULINT(EN,ENO,&(op))
#define TIME_TO_BYTE(EN,ENO,op) pTIME_TO_BYTE(EN,ENO,&(op))
#define TIME_TO_WORD(EN,ENO,op) pTIME_TO_WORD(EN,ENO,&(op))
#define TIME_TO_DWORD(EN,ENO,op) pTIME_TO_DWORD(EN,ENO,&(op))
#define TIME_TO_LWORD(EN,ENO,op) pTIME_TO_LWORD(EN,ENO,&(op))
#define DATE_TO_SINT(EN,ENO,op) pDATE_TO_SINT(EN,ENO,&(op))
#define DATE_TO_INT(EN,ENO,op) pDATE_TO_INT(EN,ENO,&(op))
#define DATE_TO_DINT(EN,ENO,op) pDATE_TO_DINT(EN,ENO,&(op))
#define DATE_TO_LINT(EN,ENO,op) pDATE_TO_LINT(EN,ENO,&(op))
#define DATE_TO_USINT(EN,ENO,op) pDATE_TO_USINT(EN,ENO,&(op))
#define DATE_TO_UINT(EN,ENO,op) pDATE_TO_UINT(EN,ENO,&(op))
#define DATE_TO_UDINT(EN,ENO,op) pDATE_TO_UDINT(EN,ENO,&(op))
#define DATE_TO_ULINT(EN,ENO,op) pDATE_TO_ULINT(EN,ENO,&(op))
#define TOD_TO_SINT(EN,ENO,op) pTOD_TO_SINT(EN,ENO,&(op))
#define TOD_TO_INT(EN,ENO,op) pTOD_TO_INT(EN,ENO,&(op))
#define TOD_TO_DINT(EN,ENO,op) pTOD_TO_DINT(EN,ENO,&(op))
#define TOD_TO_LINT(EN,ENO,op) pTOD_TO_LINT(EN,ENO,&(op))
#define TOD_TO_USINT(EN,ENO,op) pTOD_TO_USINT(EN,ENO,&(op))
#define TOD_TO_UINT(EN,ENO,op) pTOD_TO_UINT(EN,ENO,&(op))
#define TOD_TO_UDINT(EN,ENO,op) pTOD_TO_UDINT(EN,ENO,&(op))
#define TOD_TO_ULINT(EN,ENO,op) pTOD_TO_ULINT(EN,ENO,&(op))
#define DT_TO_SINT(EN,ENO,op) pDT_TO_SINT(EN,ENO,&(op))
#define DT_TO_INT(EN,ENO,op) pDT_TO_INT(EN,ENO,&(op))
#define DT_TO_DINT(EN,ENO,op) pDT_TO_DINT(EN,ENO,&(op))
#define DT_TO_LINT(EN,ENO,op) pDT_TO_LINT(EN,ENO,&(op))
#define DT_TO_USINT(EN,ENO,op) pDT_TO_USINT(EN,ENO,&(op))
#define DT_TO_UINT(EN,ENO,op) pDT_TO_UINT(EN,ENO,&(op))
#define DT_TO_UDINT(EN,ENO,op) pDT_TO_UDINT(EN,ENO,&(op))
#define DT_TO_ULINT(EN,ENO,op) pDT_TO_ULINT(EN,ENO,&(op))
#define DATE_TO_BYTE(EN,ENO,op) pDATE_TO_BYTE(EN,ENO,&(op))
#define DATE_TO_WORD(EN,ENO,op) pDATE_TO_WORD(EN,ENO,&(op))
#define DATE_TO_DWORD(EN,ENO,op) pDATE_TO_DWORD(EN,ENO,&(op))
#define DATE_TO_LWORD(EN,ENO,op) pDATE_TO_LWORD(EN,ENO,&(op))
#define TOD_TO_BYTE(EN,ENO,op) pTOD_TO_BYTE(EN,ENO,&(op))
#define TOD_TO_WORD(EN,ENO,op) pTOD_TO_WORD(EN,ENO,&(op))
#define TOD_TO_DWORD(EN,ENO,op) pTOD_TO_DWORD(EN,ENO,&(op))
#define TOD_TO_LWORD(EN,ENO,op) pTOD_TO_LWORD(EN,ENO,&(op))
#define DT_TO_BYTE(EN,ENO,op) pDT_TO_BYTE(EN,ENO,&(op))
#define DT_TO_WORD(EN,ENO,op) pDT_TO_WORD(EN,ENO,&(op))
#define DT_TO_DWORD(EN,ENO,op) pDT_TO_DWORD(EN,ENO,&(op))
#define DT_TO_LWORD(EN,ENO,op) pDT_TO_LWORD(EN,ENO,&(op))

/******** [TIME | ANY_DATE]_TO_[ANY_REAL]   ************/ 
#define __iec_(to_TYPENAME,from_TYPENAME) __convert_type_from_date_time(from_TYPENAME, to_TYPENAME, __time_to_real)
__to_anyreal_(TIME)
__ANY_DATE(__to_anyreal_)
#undef __iec_
#define TIME_TO_REAL(EN,ENO,op) pTIME_TO_REAL(EN,ENO,&(op))
#define TIME_TO_LREAL(EN,ENO,op) pTIME_TO_LREAL(EN,ENO,&(op))
#define DATE_TO_REAL(EN,ENO,op) pDATE_TO_REAL(EN,ENO,&(op))
#define DATE_TO_LREAL(EN,ENO,op) pDATE_TO_LREAL(EN,ENO,&(op))
#define TOD_TO_REAL(EN,ENO,op) pTOD_TO_REAL(EN,ENO,&(op))
#define TOD_TO_LREAL(EN,ENO,op) pTOD_TO_LREAL(EN,ENO,&(op))
#define DT_TO_REAL(EN,ENO,op) pDT_TO_REAL(EN,ENO,&(op))
#define DT_TO_LREAL(EN,ENO,op) pDT_TO_LREAL(EN,ENO,&(op))

/******** [ANY_DATE]_TO_[ANY_DATE | TIME]   ************/ 
/* Not supported: DT_TO_TIME */
inline DATE* pDT_TO_DATE(EN_ENO_PARAMS DT *op);
#define DT_TO_DATE(EN,ENO,op)	*pDT_TO_DATE(EN,ENO,&(op))
#define DATE_AND_TIME_TO_DATE	DT_TO_DATE

inline DT* pDT_TO_DT(EN_ENO_PARAMS  DT *op);
#define DT_TO_DT(EN,ENO,op)	*pDT_TO_DT(EN,ENO,&(op))

inline TOD* pDT_TO_TOD(EN_ENO_PARAMS  DT *op);
#define DT_TO_TOD(EN,ENO,op)	*pDT_TO_TOD(EN,ENO,&(op))
#define DATE_AND_TIME_TO_TIME_OF_DAY	DT_TO_TOD
/* Not supported: DATE_TO_TIME */
inline DATE* pDATE_TO_DATE(EN_ENO_PARAMS  DATE *op);
#define DATE_TO_DATE(EN,ENO,op)	*pDATE_TO_DATE(EN,ENO,&(op))
/* Not supported: DATE_TO_DT */
/* Not supported: DATE_TO_TOD */
/* Not supported: TOD_TO_TIME */
/* Not supported: TOD_TO_DATE */
/* Not supported: TOD_TO_DT */
inline TOD* pTOD_TO_TOD(EN_ENO_PARAMS  TOD *op);
#define TOD_TO_TOD(EN,ENO,op)	*pTOD_TO_TOD(EN,ENO,&(op))


/******** TIME_TO_[ANY_DATE]   ************/ 
/* Not supported: TIME_TO_DATE */
/* Not supported: TIME_TO_DT */
/* Not supported: TIME_TO_TOD */

/******** TIME_TO_TIME   ************/ 
inline TIME* pTIME_TO_TIME(EN_ENO_PARAMS  TIME *op);
#define TIME_TO_TIME(EN,ENO,op)	*pTIME_TO_TIME(EN,ENO,&(op))


/******** [ANY_BIT]_TO_STRING   ************/ 
__convert_type(BOOL, STRING, __bool_to_string)
#define __iec_(from_TYPENAME) __convert_type(from_TYPENAME, STRING, __bit_to_string)
//__ANY_NBIT(__iec_)
#undef __iec_

/******** [ANY_INT]_TO_STRING   ************/ 
#define __iec_(from_TYPENAME) __convert_type(from_TYPENAME, STRING, __sint_to_string)
//__ANY_SINT(__iec_)
#undef __iec_
#define __iec_(from_TYPENAME) __convert_type(from_TYPENAME, STRING, __uint_to_string)
//__ANY_UINT(__iec_)
#undef __iec_

/******** [ANY_REAL]_TO_STRING   ************/ 
#define __iec_(from_TYPENAME) __convert_type(from_TYPENAME, STRING, __real_to_string)
//__ANY_REAL(__iec_)
#undef __iec_

/******** [ANY_DATE]_TO_STRING   ************/ 
/* __convert_type(DATE, STRING, __date_to_string)
__convert_type(DT,   STRING, __dt_to_string)
__convert_type(TOD,  STRING, __tod_to_string) */

/******** TIME_TO_STRING   ************/ 
//__convert_type(TIME, STRING, __time_to_string)


/******** STRING_TO_[ANY_BIT]   ************/ 
__convert_type(STRING, BOOL, __string_to_bool)
#define __iec_(to_TYPENAME) __convert_type(STRING, to_TYPENAME, __string_to_bit)
//__ANY_NBIT(__iec_)
#undef __iec_

/******** STRING_TO_[ANY_INT]   ************/ 
#define __iec_(to_TYPENAME) __convert_type(STRING, to_TYPENAME, __string_to_sint)
//__ANY_SINT(__iec_)
#undef __iec_
#define __iec_(to_TYPENAME) __convert_type(STRING, to_TYPENAME, __string_to_uint)
//__ANY_UINT(__iec_)
#undef __iec_

/******** STRING_TO_[ANY_REAL]   ************/ 
#define __iec_(to_TYPENAME) __convert_type(STRING, to_TYPENAME, __string_to_real)
//__ANY_REAL(__iec_)
#undef __iec_

/******** STRING_TO_[ANY_DATE]   ************/ 
#define __iec_(to_TYPENAME) __convert_type(STRING, to_TYPENAME, __string_to_time)
//__ANY_DATE(__iec_)
#undef __iec_
                                   
/******** STRING_TO_TIME   ************/ 
//__convert_type(STRING, TIME, __string_to_time)


/********   TRUNC   ************/ 
#define __iec_(to_TYPENAME,from_TYPENAME) \
 inline to_TYPENAME TRUNC__##to_TYPENAME##__##from_TYPENAME(EN_ENO_PARAMS from_TYPENAME op);
__ANY_REAL(__to_anyint_)
#undef __iec_


/********   _TO_BCD   ************/
#define __iec_(to_TYPENAME,from_TYPENAME) \
 inline to_TYPENAME from_TYPENAME##_TO_BCD_##to_TYPENAME(EN_ENO_PARAMS from_TYPENAME op);\
 inline to_TYPENAME from_TYPENAME##_TO_BCD__##to_TYPENAME##__##from_TYPENAME(EN_ENO_PARAMS from_TYPENAME op);
__ANY_UINT(__to_anynbit_)
#undef __iec_


/********   BCD_TO_   ************/
#define __iec_(to_TYPENAME,from_TYPENAME) \
 inline to_TYPENAME from_TYPENAME##_BCD_TO_##to_TYPENAME(EN_ENO_PARAMS from_TYPENAME op);\
 inline to_TYPENAME BCD_TO_##to_TYPENAME##__##to_TYPENAME##__##from_TYPENAME(EN_ENO_PARAMS from_TYPENAME op);
__ANY_NBIT(__to_anyuint_)
#undef __iec_


/***********************************/  
/***********************************/  
/*  2.5.1.5.2 Numerical Functions  */
/***********************************/  
/***********************************/  

/* workaround for va-args limitation on shorter than int(16bit in SDCC) params */
#define VA_ARGS_REAL REAL
#define VA_ARGS_LREAL LREAL
#define VA_ARGS_SINT INT
#define VA_ARGS_INT INT
#define VA_ARGS_DINT DINT
#define VA_ARGS_LINT LINT
#define VA_ARGS_USINT UINT
#define VA_ARGS_UINT UINT
#define VA_ARGS_UDINT UDINT
#define VA_ARGS_ULINT ULINT
#define VA_ARGS_TIME TIME
#define VA_ARGS_BOOL WORD
#define VA_ARGS_BYTE WORD
#define VA_ARGS_WORD WORD
#define VA_ARGS_DWORD DWORD
#define VA_ARGS_LWORD LWORD
#define VA_ARGS_STRING STRING
#define VA_ARGS_WSTRING WSTRING
#define VA_ARGS_DATE DATE
#define VA_ARGS_TOD TOD
#define VA_ARGS_DT DT


#define __numeric(fname,TYPENAME, FUNC) \
/* explicitly typed function */\
 inline TYPENAME fname##TYPENAME(EN_ENO_PARAMS TYPENAME op);\
/* overloaded function */\
 inline TYPENAME fname##_##TYPENAME##__##TYPENAME(EN_ENO_PARAMS TYPENAME op);

/******************************************************************/
/***   Table 23 - Standard functions of one numeric variable    ***/
/******************************************************************/

  /**************/
  /*    ABS     */
  /**************/
#define __abs_signed(TYPENAME) \
/* explicitly typed function */\
 inline TYPENAME ABS_##TYPENAME(EN_ENO_PARAMS TYPENAME op);\
/* overloaded function */\
 inline TYPENAME ABS__##TYPENAME##__##TYPENAME(EN_ENO_PARAMS TYPENAME op);

#define __abs_unsigned(TYPENAME) \
/* explicitly typed function */\
 inline TYPENAME ABS_##TYPENAME(EN_ENO_PARAMS TYPENAME op);\
/* overloaded function */\
 inline TYPENAME ABS__##TYPENAME##__##TYPENAME(EN_ENO_PARAMS TYPENAME op);


__ANY_REAL(__abs_signed)
__ANY_SINT(__abs_signed)
__ANY_UINT(__abs_unsigned)


  /**************/
  /*    SQRT    */
  /**************/
#define __sqrt(TYPENAME) __numeric(SQRT_, TYPENAME, sqrt)
__ANY_REAL(__sqrt)


/**************/
  /*     LN     */
  /**************/
#define __ln(TYPENAME) __numeric(LN_, TYPENAME, log)
__ANY_REAL(__ln)


  /**************/
  /*     LOG    */
  /**************/
#define __log(TYPENAME) __numeric(LOG_, TYPENAME, log10)
__ANY_REAL(__log)


  /**************/
  /*     EXP    */
  /**************/
#define __exp(TYPENAME) __numeric(EXP_, TYPENAME, exp)
__ANY_REAL(__exp)


  /**************/
  /*     SIN    */
  /**************/
#define __sin(TYPENAME) __numeric(SIN_, TYPENAME, sin)
__ANY_REAL(__sin)


  /**************/
  /*     COS    */
  /**************/
#define __cos(TYPENAME) __numeric(COS_, TYPENAME, cos)
__ANY_REAL(__cos)

  /**************/
  /*     TAN    */
  /**************/
#define __tan(TYPENAME) __numeric(TAN_, TYPENAME, tan)
__ANY_REAL(__tan)


  /**************/
  /*    ASIN    */
  /**************/
#define __asin(TYPENAME) __numeric(ASIN_, TYPENAME, asin)
__ANY_REAL(__asin)

  /**************/
  /*    ACOS    */
  /**************/
#define __acos(TYPENAME) __numeric(ACOS_, TYPENAME, acos)
__ANY_REAL(__acos)

  /**************/
  /*    ATAN    */
  /**************/
#define __atan(TYPENAME) __numeric(ATAN_, TYPENAME, atan)
__ANY_REAL(__atan)



/*****************************************************/
/***   Table 24 - Standard arithmetic functions    ***/
/*****************************************************/

#define __arith_expand(fname,TYPENAME, OP)\
 inline TYPENAME fname(EN_ENO_PARAMS UINT param_count, TYPENAME op1, ...);

#define __arith_(fname,TYPENAME, OP)\
/* explicitly typed function */\
 inline TYPENAME fname##TYPENAME(EN_ENO_PARAMS TYPENAME op1, TYPENAME op2);\
/* overloaded function */\
 inline TYPENAME fname##_##TYPENAME##__##TYPENAME##__##TYPENAME(EN_ENO_PARAMS TYPENAME op1, TYPENAME op2);

  /**************/
  /*     ADD    */
  /**************/
#define __add(TYPENAME) \
__arith_expand(ADD_##TYPENAME, TYPENAME, +) 			 /* explicitly typed function */\
__arith_expand(ADD__##TYPENAME##__##TYPENAME, TYPENAME, +)	 /* overloaded function */
__ANY_NUM(__add)


  /**************/
  /*     MUL    */
  /**************/
#define __mul(TYPENAME) \
__arith_expand(MUL_##TYPENAME, TYPENAME, *) 			 /* explicitly typed function */\
__arith_expand(MUL__##TYPENAME##__##TYPENAME, TYPENAME, *)	 /* overloaded function */
__ANY_NUM(__mul)


  /**************/
  /*     SUB    */
  /**************/
#define __sub(TYPENAME) __arith_(SUB_, TYPENAME, -)
__ANY_NUM(__sub)


  /**************/
  /*     DIV    */
  /**************/
#define __div(TYPENAME)\
/* The explicitly typed standard functions */\
 inline TYPENAME DIV_##TYPENAME(EN_ENO_PARAMS TYPENAME op1, TYPENAME op2);\
/* The overloaded standard functions */\
 inline TYPENAME DIV__##TYPENAME##__##TYPENAME##__##TYPENAME(EN_ENO_PARAMS TYPENAME op1, TYPENAME op2);
__ANY_NUM(__div)


  /**************/
  /*     MOD    */
  /**************/
#define __mod(TYPENAME)\
/* The explicitly typed standard functions */\
 inline TYPENAME MOD_##TYPENAME(EN_ENO_PARAMS TYPENAME op1, TYPENAME op2);\
/* The overloaded standard functions */\
 inline TYPENAME MOD__##TYPENAME##__##TYPENAME##__##TYPENAME(EN_ENO_PARAMS TYPENAME op1, TYPENAME op2);
__ANY_INT(__mod)

  /**************/
  /*    EXPT    */
  /**************/
/* overloaded function */
#define __iec_(in1_TYPENAME,in2_TYPENAME) \
 inline in1_TYPENAME EXPT__##in1_TYPENAME##__##in1_TYPENAME##__##in2_TYPENAME\
  (EN_ENO_PARAMS in1_TYPENAME IN1, in2_TYPENAME IN2);
#define __in1_anyreal_(in2_TYPENAME)   __ANY_REAL_1(__iec_,in2_TYPENAME)
__ANY_NUM(__in1_anyreal_)
#undef __iec_

  

  /***************/
  /*     MOVE    */
  /***************/
/* The explicitly typed standard functions */
#define __iec_(TYPENAME)\
 inline TYPENAME MOVE_##TYPENAME(EN_ENO_PARAMS TYPENAME op1);
__ANY(__iec_)
#undef __iec_

/* Overloaded function */
#define __iec_(TYPENAME)\
 inline TYPENAME MOVE__##TYPENAME##__##TYPENAME(EN_ENO_PARAMS TYPENAME op1);
__ANY(__iec_)
#undef __iec_

/*for DATE/TIME data types */
inline DATE* pMOVE_DATE(EN_ENO_PARAMS DATE *op1);
#define MOVE_DATE(EN,ENO,op1) *pMOVE_DATE(EN,ENO,&(op1))
#define MOVE__DATE__DATE(EN,ENO,op1) *pMOVE_DATE(EN,ENO,&(op1))

inline TOD* pMOVE_TOD(EN_ENO_PARAMS TOD *op1);
#define MOVE_TOD(EN,ENO,op1) *pMOVE_TOD(EN,ENO,&(op1))
#define MOVE__TOD__TOD(EN,ENO,op1) *pMOVE_TOD(EN,ENO,&(op1))

inline DT* pMOVE_DT(EN_ENO_PARAMS DT *op1);
#define MOVE_DT(EN,ENO,op1) *pMOVE_DT(EN,ENO,&(op1))
#define MOVE__DT__DT(EN,ENO,op1) *pMOVE_DT(EN,ENO,&(op1))

inline TIME* pMOVE_TIME(EN_ENO_PARAMS TIME *op1);
#define MOVE_TIME(EN,ENO,op1) *pMOVE_TIME(EN,ENO,&(op1))
#define MOVE__TIME__TIME(EN,ENO,op1) *pMOVE_TIME(EN,ENO,&(op1))

/***********************************/  
/***********************************/  
/*  2.5.1.5.3 Bit String Functions */
/***********************************/  
/***********************************/  

/****************************************************/
/***   Table 25 - Standard bit shift functions    ***/
/****************************************************/

/* We do not delcare explcitly typed versions of the functions in table 25.
 * See note above regarding explicitly typed functions for more details.
 */
#define __in1_anynbit_(in2_TYPENAME)   __ANY_NBIT_1(__iec_,in2_TYPENAME)

#define __shift_(fname, in1_TYPENAME, in2_TYPENAME, OP)\
 inline in1_TYPENAME fname(EN_ENO_PARAMS in1_TYPENAME IN, in2_TYPENAME N);

  /**************/
  /*     SHL    */
  /**************/
#define __iec_(TYPENAME) \
/* Overloaded function */\
 inline BOOL SHL__BOOL__##TYPENAME(EN_ENO_PARAMS BOOL IN, TYPENAME N) ;
__ANY_INT(__iec_)
#undef __iec_


#define __iec_(in1_TYPENAME,in2_TYPENAME) \
__shift_(SHL__##in1_TYPENAME##__##in1_TYPENAME##__##in2_TYPENAME, in1_TYPENAME, in2_TYPENAME, << )/* Overloaded function */
__ANY_INT(__in1_anynbit_)
#undef __iec_


  /**************/
  /*     SHR    */
  /**************/
#define __iec_(TYPENAME) \
/* Overloaded function */\
 inline BOOL SHR__BOOL__##TYPENAME(EN_ENO_PARAMS BOOL IN, TYPENAME N);
__ANY_INT(__iec_)
#undef __iec_


#define __iec_(in1_TYPENAME,in2_TYPENAME) \
__shift_(SHR__##in1_TYPENAME##__##in1_TYPENAME##__##in2_TYPENAME, in1_TYPENAME, in2_TYPENAME, >> )/* Overloaded function */
__ANY_INT(__in1_anynbit_)
#undef __iec_


  /**************/
  /*     ROR    */
  /**************/
#define __iec_(TYPENAME) \
/* Overloaded function */\
 inline BOOL ROR__BOOL__##TYPENAME(EN_ENO_PARAMS BOOL IN, TYPENAME N);
__ANY_INT(__iec_)
#undef __iec_


#define __iec_(in1_TYPENAME,in2_TYPENAME) \
 inline in1_TYPENAME ROR__##in1_TYPENAME##__##in1_TYPENAME##__##in2_TYPENAME(EN_ENO_PARAMS in1_TYPENAME IN, in2_TYPENAME N);
__ANY_INT(__in1_anynbit_)
#undef __iec_


  /**************/
  /*     ROL    */
  /**************/
#define __iec_(TYPENAME) \
/* Overloaded function */\
 inline BOOL ROL__BOOL__##TYPENAME(EN_ENO_PARAMS BOOL IN, TYPENAME N);
__ANY_INT(__iec_)
#undef __iec_


#define __iec_(in1_TYPENAME,in2_TYPENAME) \
 inline in1_TYPENAME ROL__##in1_TYPENAME##__##in1_TYPENAME##__##in2_TYPENAME(EN_ENO_PARAMS in1_TYPENAME IN, in2_TYPENAME N);
__ANY_INT(__in1_anynbit_)
#undef __iec_



/*********************/
/***   Table 26    ***/
/*********************/

  /**************/
  /*     AND    */
  /**************/
__arith_expand(AND_BOOL, BOOL, && )         /* The explicitly typed standard functions */
__arith_expand(AND__BOOL__BOOL, BOOL, && )  /* Overloaded function */

#define __iec_(TYPENAME) \
__arith_expand(AND_##TYPENAME, TYPENAME, &)  /* The explicitly typed standard functions */\
__arith_expand(AND__##TYPENAME##__##TYPENAME, TYPENAME, &)  /* Overloaded function */
__ANY_NBIT(__iec_)
#undef __iec_

  /*************/
  /*     OR    */
  /*************/
__arith_expand(OR_BOOL, BOOL, || )         /* The explicitly typed standard functions */
__arith_expand(OR__BOOL__BOOL, BOOL, || )  /* Overloaded function */

#define __iec_(TYPENAME) \
__arith_expand(OR_##TYPENAME, TYPENAME, |)  /* The explicitly typed standard functions */\
__arith_expand(OR__##TYPENAME##__##TYPENAME, TYPENAME, |)  /* Overloaded function */
__ANY_NBIT(__iec_)
#undef __iec_

  /**************/
  /*     XOR    */
  /**************/
#define __xorbool_expand(fname) \
 inline BOOL fname(EN_ENO_PARAMS UINT param_count, BOOL op1, ...);

__xorbool_expand(XOR_BOOL) /* The explicitly typed standard functions */
__xorbool_expand(XOR__BOOL__BOOL) /* Overloaded function */

#define __iec_(TYPENAME) \
__arith_expand(XOR_##TYPENAME, TYPENAME, ^) /* The explicitly typed standard functions */\
__arith_expand(XOR__##TYPENAME##__##TYPENAME, TYPENAME, ^) /* Overloaded function */
__ANY_NBIT(__iec_)
#undef __iec_


  /**************/
  /*     NOT    */
  /**************/
/* The explicitly typed standard functions */
 inline BOOL NOT_BOOL(EN_ENO_PARAMS BOOL op1);

/* Overloaded function */
 inline BOOL NOT__BOOL__BOOL(EN_ENO_PARAMS BOOL op1);

/* The explicitly typed standard functions */
#define __iec_(TYPENAME)\
 inline TYPENAME NOT_##TYPENAME(EN_ENO_PARAMS TYPENAME op1);
__ANY_NBIT(__iec_)
#undef __iec_

/* Overloaded function */
#define __iec_(TYPENAME)\
 inline TYPENAME NOT__##TYPENAME##__##TYPENAME(EN_ENO_PARAMS TYPENAME op1);
__ANY_NBIT(__iec_)
#undef __iec_






/***************************************************/  
/***************************************************/  
/*  2.5.1.5.4  Selection and comparison Functions  */
/***************************************************/  
/***************************************************/  

/*********************/
/***   Table 27    ***/
/*********************/


    /**************/
    /*    SEL     */
    /**************/

/* The explicitly typed standard functions */
#define __iec_(TYPENAME)\
 inline TYPENAME SEL_##TYPENAME(EN_ENO_PARAMS BOOL G, TYPENAME op0, TYPENAME op1);
__ANY(__iec_)
#undef __iec_

/* Overloaded function */
#define __iec_(TYPENAME)\
 inline TYPENAME SEL__##TYPENAME##__BOOL__##TYPENAME##__##TYPENAME(EN_ENO_PARAMS BOOL G, TYPENAME op0, TYPENAME op1);
__ANY(__iec_)
#undef __iec_

/* SEL for time data types */	
/*changed from original variadic to static function with two (2) arguments only 
it will raise a compile-time error when more arguments used
*/
inline DATE* pSEL_DATE(EN_ENO_PARAMS BOOL G, DATE *op0, DATE *op1);
#define	SEL_DATE(EN,ENO,G,op0, op1)	*pSEL_DATE(EN,ENO,G,&(op0), &(op1))
#define	SEL__DATE__BOOL__DATE__DATE(EN,ENO,G,op0, op1)	*pSEL_DATE(EN,ENO,G,&(op0), &(op1))

inline TOD* pSEL_TOD(EN_ENO_PARAMS BOOL G, TOD *op0, TOD *op1);
#define	SEL_TOD(EN,ENO,G,op0, op1)	*pSEL_TOD(EN,ENO,G,&(op0), &(op1))
#define	SEL__TOD__BOOL__TOD__TOD(EN,ENO,G,op0, op1)	*pSEL_TOD(EN,ENO,G,&(op0), &(op1))

inline DT* pSEL_DT(EN_ENO_PARAMS BOOL G, DT *op0, DT *op1);
#define	SEL_DT(EN,ENO,G,op0, op1)	*pSEL_DT(EN,ENO,G,&(op0), &(op1))
#define	SEL__DT__BOOL__DT__DT(EN,ENO,G,op0, op1)	*pSEL_DT(EN,ENO,G,&(op0), &(op1))

inline TIME* pSEL_TIME(EN_ENO_PARAMS BOOL G, TIME *op0, TIME *op1);
#define	SEL_TIME(EN,ENO,G,op0, op1)	*pSEL_TIME(EN,ENO,G,&(op0), &(op1))
#define	SEL__TIME__BOOL__TIME__TIME(EN,ENO,G,op0, op1)	*pSEL_TIME(EN,ENO,G,&(op0), &(op1))

    /**************/
    /*     MAX    */
    /**************/

#define __extrem_(fname,TYPENAME, COND) \
 inline TYPENAME fname(EN_ENO_PARAMS UINT param_count, TYPENAME op1, ...);

/* Max for numerical data types */	
#define __iec_(TYPENAME) \
__extrem_(MAX_##TYPENAME,TYPENAME, op1 < tmp) /* The explicitly typed standard functions */\
__extrem_(MAX__##TYPENAME##__##TYPENAME,TYPENAME, op1 < tmp) /* Overloaded function */
__ANY_BIT(__iec_)
__ANY_NUM(__iec_)
#undef __iec_

/* Max for time data types */	
/*changed from original variadic to static function with two (2) arguments only 
it will raise a compile-time error when more arguments used
*/
inline DATE* pMAX_DATE(EN_ENO_PARAMS DATE *op1, DATE *op2);
#define MAX_DATE(EN,ENO,param_count,op1,op2) *pMAX_DATE(EN,ENO,&(op1),&(op2))
#define MAX__DATE__DATE(EN,ENO,param_count,op1,op2) *pMAX_DATE(EN,ENO,&(op1),&(op2))

inline TOD* pMAX_TOD(EN_ENO_PARAMS TOD *op1, TOD *op2);
#define MAX_TOD(EN,ENO,param_count,op1,op2) *pMAX_TOD(EN,ENO,&(op1),&(op2))
#define MAX__TOD__TOD(EN,ENO,param_count,op1,op2) *pMAX_TOD(EN,ENO,&(op1),&(op2))

inline DT* pMAX_DT(EN_ENO_PARAMS DT *op1, DT *op2);
#define MAX_DT(EN,ENO,param_count,op1,op2) *pMAX_DT(EN,ENO,&(op1),&(op2))
#define MAX__DT__DT(EN,ENO,param_count,op1,op2) *pMAX_DT(EN,ENO,&(op1),&(op2))

inline TIME* pMAX_TIME(EN_ENO_PARAMS TIME *op1, TIME *op2);
#define MAX_TIME(EN,ENO,param_count,op1,op2) *pMAX_TIME(EN,ENO,&(op1),&(op2))
#define MAX__TIME__TIME(EN,ENO,param_count,op1,op2) *pMAX_TIME(EN,ENO,&(op1),&(op2))

inline int __str_cmp(uint8_t* str1, __strlen_t len1, uint8_t* str2, __strlen_t len2);
#define __STR_CMP(str1, str2) __str_cmp(str1.body, str1.len, str2.body, str2.len)

/* Max for string data types */	
__extrem_(MAX_STRING, STRING, __STR_CMP(op1,tmp) < 0) /* The explicitly typed standard functions */
__extrem_(MAX__STRING__STRING, STRING, __STR_CMP(op1,tmp) < 0) /* Overloaded function */

    /**************/
    /*     MIN    */
    /**************/
/* Min for numerical data types */	
#define __iec_(TYPENAME) \
__extrem_(MIN_##TYPENAME, TYPENAME, op1 > tmp) /* The explicitly typed standard functions */\
__extrem_(MIN__##TYPENAME##__##TYPENAME, TYPENAME, op1 > tmp) /* Overloaded function */
__ANY_NBIT(__iec_)
__ANY_NUM(__iec_)
#undef __iec_

/* Min for time data types */	
/*changed from original variadic to static function with two (2) arguments only 
it will raise a compile-time error when more arguments used
*/
inline DATE* pMIN_DATE(EN_ENO_PARAMS DATE *op1, DATE *op2);
#define MIN_DATE(EN,ENO,param_count,op1,op2) *pMIN_DATE(EN,ENO,&(op1),&(op2))
#define MIN__DATE__DATE(EN,ENO,param_count,op1,op2) *pMIN_DATE(EN,ENO,&(op1),&(op2))

inline TOD* pMIN_TOD(EN_ENO_PARAMS TOD *op1, TOD *op2);
#define MIN_TOD(EN,ENO,param_count,op1,op2) *pMIN_TOD(EN,ENO,&(op1),&(op2))
#define MIN__TOD__TOD(EN,ENO,param_count,op1,op2) *pMIN_TOD(EN,ENO,&(op1),&(op2))

inline DT* pMIN_DT(EN_ENO_PARAMS DT *op1, DT *op2);
#define MIN_DT(EN,ENO,param_count,op1,op2) *pMIN_DT(EN,ENO,&(op1),&(op2))
#define MIN__DT__DT(EN,ENO,param_count,op1,op2) *pMIN_DT(EN,ENO,&(op1),&(op2))

inline TIME* pMIN_TIME(EN_ENO_PARAMS TIME *op1, TIME *op2);
#define MIN_TIME(EN,ENO,param_count,op1,op2) *pMIN_TIME(EN,ENO,&(op1),&(op2))
#define MIN__TIME__TIME(EN,ENO,param_count,op1,op2) *pMIN_TIME(EN,ENO,&(op1),&(op2))

/* Min for string data types */
__extrem_(MIN_STRING, STRING, __STR_CMP(op1,tmp) > 0) /* The explicitly typed standard functions */
__extrem_(MIN__STRING__STRING, STRING, __STR_CMP(op1,tmp) > 0) /* Overloaded function */

    /**************/
    /*   LIMIT    */
    /**************/

/* Limit for numerical data types */
#define __iec_(TYPENAME)\
/* The explicitly typed standard functions */\
 inline TYPENAME LIMIT_##TYPENAME(EN_ENO_PARAMS TYPENAME MN, TYPENAME IN, TYPENAME MX);\
/* Overloaded function */\
 inline TYPENAME LIMIT__##TYPENAME##__##TYPENAME##__##TYPENAME##__##TYPENAME(EN_ENO_PARAMS TYPENAME MN, TYPENAME IN, TYPENAME MX);
__ANY_NBIT(__iec_)
__ANY_NUM(__iec_)
#undef __iec_


/* Limit for time data types */	

inline DATE* pLIMIT_DATE(EN_ENO_PARAMS DATE *MN, DATE *IN, DATE *MX);
#define LIMIT_DATE(EN,ENO,MN,IN,MX) *pLIMIT_DATE(EN,ENO,&(MN),&(IN),&(MX))
#define LIMIT__DATE__DATE__DATE__DATE(EN,ENO,MN,IN,MX) *pLIMIT_DATE(EN,ENO,&(MN),&(IN),&(MX))

inline TOD* pLIMIT_TOD(EN_ENO_PARAMS TOD *MN, TOD *IN, TOD *MX);
#define LIMIT_TOD(EN,ENO,MN,IN,MX) *pLIMIT_TOD(EN,ENO,&(MN),&(IN),&(MX))
#define LIMIT__TOD__TOD__TOD__TOD(EN,ENO,MN,IN,MX) *pLIMIT_TOD(EN,ENO,&(MN),&(IN),&(MX))

inline DT* pLIMIT_DT(EN_ENO_PARAMS DT *MN, DT *IN, DT *MX);
#define LIMIT_DT(EN,ENO,MN,IN,MX) *pLIMIT_DT(EN,ENO,&(MN),&(IN),&(MX))
#define LIMIT__DT__DT__DT__DT(EN,ENO,MN,IN,MX) *pLIMIT_DT(EN,ENO,&(MN),&(IN),&(MX))

inline TIME* pLIMIT_TIME(EN_ENO_PARAMS TIME *MN, TIME *IN, TIME *MX);
#define LIMIT_TIME(EN,ENO,MN,IN,MX) *pLIMIT_TIME(EN,ENO,&(MN),&(IN),&(MX))
#define LIMIT__TIME__TIME__TIME__TIME(EN,ENO,MN,IN,MX) *pLIMIT_TIME(EN,ENO,&(MN),&(IN),&(MX))

/* Limit for string data types */	
/* The explicitly typed standard functions */
 //inline STRING LIMIT_STRING(EN_ENO_PARAMS STRING MN, STRING IN, STRING MX);

/* Overloaded function */
 //inline STRING LIMIT__STRING__STRING__STRING__STRING(EN_ENO_PARAMS STRING MN, STRING IN, STRING MX);


    /**************/
    /*     MUX    */
    /**************/
/* The standard states that the inputs for SEL and MUX must be named starting off from 0,
 * unlike remaining functions, that start off at 1.
 */    
/* The explicitly typed standard functions */
#define __in1_anyint_(in2_TYPENAME)   __ANY_INT_1(__iec_,in2_TYPENAME)
#define __iec_(in1_TYPENAME,in2_TYPENAME) \
 inline in2_TYPENAME MUX__##in2_TYPENAME##__##in1_TYPENAME##__##in2_TYPENAME(EN_ENO_PARAMS in1_TYPENAME K, UINT param_count, ...);

__ANY(__in1_anyint_)
#undef __iec_

/* MUX for time data types */	
/* NOT IMPLEMENTED YET */	

/******************************************/
/***             Table 28               ***/
/***   Standard comparison functions    ***/
/******************************************/

#define __compare_(fname,TYPENAME, COND) \
 inline BOOL fname(EN_ENO_PARAMS UINT param_count, TYPENAME op1, ...);

#define __compare_num(fname, TYPENAME, TEST) __compare_(fname, TYPENAME, op1 TEST tmp )
#define __compare_time(fname, TYPENAME, TEST) __compare_(fname, TYPENAME, __time_cmp(op1, tmp) TEST 0)
#define __compare_string(fname, TEST) __compare_(fname, STRING, __STR_CMP(op1, tmp) TEST 0 )


    /**************/
    /*     GT     */
    /**************/
/* Comparison for numerical data types */
#define __iec_(TYPENAME) \
__compare_num(GT_##TYPENAME, TYPENAME, > ) /* The explicitly typed standard functions */\
__compare_num(GT__BOOL__##TYPENAME, TYPENAME, > ) /* Overloaded function */
__ANY_NBIT(__iec_)
__ANY_NUM(__iec_)
#undef __iec_

/* Comparison for time data types */	
/*changed from original variadic to static function with two (2) arguments only 
it will raise a compile-time error when more arguments used
*/	
inline BOOL pGT_DATE(EN_ENO_PARAMS DATE *op1, DATE *op2);
#define	GT_DATE(EN,ENO,param_count,op1, op2)	pGT_DATE(EN,ENO,&(op1),&(op2))
#define	GT__BOOL__DATE(EN,ENO,param_count,op1, op2)	pGT_DATE(EN,ENO,&(op1),&(op2))

inline BOOL pGT_TOD(EN_ENO_PARAMS TOD *op1, TOD *op2);
#define	GT_TOD(EN,ENO,param_count,op1, op2)	pGT_TOD(EN,ENO,&(op1),&(op2))
#define	GT__BOOL__TOD(EN,ENO,param_count,op1, op2)	pGT_TOD(EN,ENO,&(op1),&(op2))

inline BOOL pGT_DT(EN_ENO_PARAMS DT *op1, DT *op2);
#define	GT_DT(EN,ENO,param_count,op1, op2)	pGT_DT(EN,ENO,&(op1),&(op2))
#define	GT__BOOL__DT(EN,ENO,param_count,op1, op2)	pGT_DT(EN,ENO,&(op1),&(op2))

inline BOOL pGT_TIME(EN_ENO_PARAMS TIME *op1, TIME *op2);
#define	GT_TIME(EN,ENO,param_count,op1, op2)	pGT_TIME(EN,ENO,&(op1),&(op2))
#define	GT__BOOL__TIME(EN,ENO,param_count,op1, op2)	pGT_TIME(EN,ENO,&(op1),&(op2))

/* Comparison for string data types */	
__compare_string(GT_STRING, > ) /* The explicitly typed standard functions */
__compare_string(GT__BOOL__STRING, > ) /* Overloaded function */

    /**************/
    /*     GE     */
    /**************/
/* Comparison for numerical data types */
#define __iec_(TYPENAME) \
__compare_num(GE_##TYPENAME, TYPENAME, >= ) /* The explicitly typed standard functions */\
__compare_num(GE__BOOL__##TYPENAME, TYPENAME, >= ) /* Overloaded function */
__ANY_NBIT(__iec_)
__ANY_NUM(__iec_)
#undef __iec_

/* Comparison for time data types */	
/*changed from original variadic to static function with two (2) arguments only 
it will raise a compile-time error when more arguments used
*/	
inline BOOL pGE_DATE(EN_ENO_PARAMS DATE *op1, DATE *op2);
#define	GE_DATE(EN,ENO,param_count,op1, op2)	pGE_DATE(EN,ENO,&(op1),&(op2))
#define	GE__BOOL__DATE(EN,ENO,param_count,op1, op2)	pGE_DATE(EN,ENO,&(op1),&(op2))

inline BOOL pGE_TOD(EN_ENO_PARAMS TOD *op1, TOD *op2);
#define	GE_TOD(EN,ENO,param_count,op1, op2)	pGE_TOD(EN,ENO,&(op1),&(op2))
#define	GE__BOOL__TOD(EN,ENO,param_count,op1, op2)	pGE_TOD(EN,ENO,&(op1),&(op2))

inline BOOL pGE_DT(EN_ENO_PARAMS DT *op1, DT *op2);
#define	GE_DT(EN,ENO,param_count,op1, op2)	pGE_DT(EN,ENO,&(op1),&(op2))
#define	GE__BOOL__DT(EN,ENO,param_count,op1, op2)	pGE_DT(EN,ENO,&(op1),&(op2))

inline BOOL pGE_TIME(EN_ENO_PARAMS TIME *op1, TIME *op2);
#define	GE_TIME(EN,ENO,param_count,op1, op2)	pGE_TIME(EN,ENO,&(op1),&(op2))
#define	GE__BOOL__TIME(EN,ENO,param_count,op1, op2)	pGE_TIME(EN,ENO,&(op1),&(op2))

/* Comparison for string data types */	
__compare_string(GE_STRING, >= ) /* The explicitly typed standard functions */
__compare_string(GE__BOOL__STRING, >= ) /* Overloaded function */



    /**************/
    /*     EQ     */
    /**************/
/* Comparison for numerical data types */
#define __iec_(TYPENAME) \
__compare_num(EQ_##TYPENAME, TYPENAME, == ) /* The explicitly typed standard functions */\
__compare_num(EQ__BOOL__##TYPENAME, TYPENAME, == ) /* Overloaded function */
__ANY_NBIT(__iec_)
__ANY_NUM(__iec_)
#undef __iec_

/* Comparison for time data types */	
/*changed from original variadic to static function with two (2) arguments only 
it will raise a compile-time error when more arguments used
*/
inline BOOL pEQ_DATE(EN_ENO_PARAMS DATE *op1, DATE *op2);
#define	EQ_DATE(EN,ENO,param_count,op1, op2)	pEQ_DATE(EN,ENO,&(op1),&(op2))
#define	EQ__BOOL__DATE(EN,ENO,param_count,op1, op2)	pEQ_DATE(EN,ENO,&(op1),&(op2))

inline BOOL pEQ_TOD(EN_ENO_PARAMS TOD *op1, TOD *op2);
#define	EQ_TOD(EN,ENO,param_count,op1, op2)	pEQ_TOD(EN,ENO,&(op1),&(op2))
#define	EQ__BOOL__TOD(EN,ENO,param_count,op1, op2)	pEQ_TOD(EN,ENO,&(op1),&(op2))

inline BOOL pEQ_DT(EN_ENO_PARAMS DT *op1, DT *op2);
#define	EQ_DT(EN,ENO,param_count,op1, op2)	pEQ_DT(EN,ENO,&(op1),&(op2))
#define	EQ__BOOL__DT(EN,ENO,param_count,op1, op2)	pEQ_DT(EN,ENO,&(op1),&(op2))

inline BOOL pEQ_TIME(EN_ENO_PARAMS TIME *op1, TIME *op2);
#define	EQ_TIME(EN,ENO,param_count,op1, op2)	pEQ_TIME(EN,ENO,&(op1),&(op2))
#define	EQ__BOOL__TIME(EN,ENO,param_count,op1, op2)	pEQ_TIME(EN,ENO,&(op1),&(op2))

/* Comparison for string data types */	
__compare_string(EQ_STRING, == ) /* The explicitly typed standard functions */
__compare_string(EQ__BOOL__STRING, == ) /* Overloaded function */


    /**************/
    /*     LT     */
    /**************/
/* Comparison for numerical data types */
#define __iec_(TYPENAME) \
__compare_num(LT_##TYPENAME, TYPENAME, < ) /* The explicitly typed standard functions */\
__compare_num(LT__BOOL__##TYPENAME, TYPENAME, < ) /* Overloaded function */
__ANY_NBIT(__iec_)
__ANY_NUM(__iec_)
#undef __iec_

/* Comparison for time data types */	
/*changed from original variadic to static function with two (2) arguments only 
it will raise a compile-time error when more arguments used
*/
inline BOOL pLT_DATE(EN_ENO_PARAMS DATE *op1, DATE *op2);
#define	LT_DATE(EN,ENO,param_count,op1, op2)	pLT_DATE(EN,ENO,&(op1),&(op2))
#define	LT__BOOL__DATE(EN,ENO,param_count,op1, op2)	pLT_DATE(EN,ENO,&(op1),&(op2))

inline BOOL pLT_TOD(EN_ENO_PARAMS TOD *op1, TOD *op2);
#define	LT_TOD(EN,ENO,param_count,op1, op2)	pLT_TOD(EN,ENO,&(op1),&(op2))
#define	LT__BOOL__TOD(EN,ENO,param_count,op1, op2)	pLT_TOD(EN,ENO,&(op1),&(op2))

inline BOOL pLT_DT(EN_ENO_PARAMS DT *op1, DT *op2);
#define	LT_DT(EN,ENO,param_count,op1, op2)	pLT_DT(EN,ENO,&(op1),&(op2))
#define	LT__BOOL__DT(EN,ENO,param_count,op1, op2)	pLT_DT(EN,ENO,&(op1),&(op2))

inline BOOL pLT_TIME(EN_ENO_PARAMS TIME *op1, TIME *op2);
#define	LT_TIME(EN,ENO,param_count,op1, op2)	pLT_TIME(EN,ENO,&(op1),&(op2))
#define	LT__BOOL__TIME(EN,ENO,param_count,op1, op2)	pLT_TIME(EN,ENO,&(op1),&(op2))

/* Comparison for string data types */	
__compare_string(LT_STRING, < ) /* The explicitly typed standard functions */
__compare_string(LT__BOOL__STRING, < ) /* Overloaded function */


    /**************/
    /*     LE     */
    /**************/
/* Comparison for numerical data types */
#define __iec_(TYPENAME) \
__compare_num(LE_##TYPENAME, TYPENAME, <= ) /* The explicitly typed standard functions */\
__compare_num(LE__BOOL__##TYPENAME, TYPENAME, <= ) /* Overloaded function */
__ANY_NBIT(__iec_)
__ANY_NUM(__iec_)
#undef __iec_

/* Comparison for time data types */	
/* Comparison for time data types */	
/*changed from original variadic to static function with two (2) arguments only 
it will raise a compile-time error when more arguments used
*/
inline BOOL pLE_DATE(EN_ENO_PARAMS DATE *op1, DATE *op2);
#define	LE_DATE(EN,ENO,param_count,op1, op2)	pLE_DATE(EN,ENO,&(op1),&(op2))
#define	LE__BOOL__DATE(EN,ENO,param_count,op1, op2)	pLE_DATE(EN,ENO,&(op1),&(op2))

inline BOOL pLE_TOD(EN_ENO_PARAMS TOD *op1, TOD *op2);
#define	LE_TOD(EN,ENO,param_count,op1, op2)	pLE_TOD(EN,ENO,&(op1),&(op2))
#define	LE__BOOL__TOD(EN,ENO,param_count,op1, op2)	pLE_TOD(EN,ENO,&(op1),&(op2))

inline BOOL pLE_DT(EN_ENO_PARAMS DT *op1, DT *op2);
#define	LE_DT(EN,ENO,param_count,op1, op2)	pLE_DT(EN,ENO,&(op1),&(op2))
#define	LE__BOOL__DT(EN,ENO,param_count,op1, op2)	pLE_DT(EN,ENO,&(op1),&(op2))

inline BOOL pLE_TIME(EN_ENO_PARAMS TIME *op1, TIME *op2);
#define	LE_TIME(EN,ENO,param_count,op1, op2)	pLE_TIME(EN,ENO,&(op1),&(op2))
#define	LE__BOOL__TIME(EN,ENO,param_count,op1, op2)	pLE_TIME(EN,ENO,&(op1),&(op2))

/* Comparison for string data types */	
__compare_string(LE_STRING, <= ) /* The explicitly typed standard functions */
__compare_string(LE__BOOL__STRING, <= ) /* Overloaded function */


    /**************/
    /*     NE     */
    /**************/
#define __ne_num(fname, TYPENAME) \
 inline BOOL fname(EN_ENO_PARAMS TYPENAME op1, TYPENAME op2);

#define __ne_time(fname, TYPENAME) \
 inline BOOL fname(EN_ENO_PARAMS TYPENAME op1, TYPENAME op2);

#define __ne_string(fname, TYPENAME) \
 inline BOOL fname(EN_ENO_PARAMS TYPENAME op1, TYPENAME op2);

/* Comparison for numerical data types */
#define __iec_(TYPENAME) \
__ne_num(NE_##TYPENAME, TYPENAME) /* The explicitly typed standard functions */\
__ne_num(NE__BOOL__##TYPENAME##__##TYPENAME, TYPENAME) /* Overloaded function */
__ANY_BIT(__iec_)
__ANY_NUM(__iec_)
#undef __iec_

/* Comparison for time data types */	
/*changed from original variadic to static function with two (2) arguments only 
it will raise a compile-time error when more arguments used
*/
inline BOOL pNE_DATE(EN_ENO_PARAMS DATE *op1, DATE *op2);
#define	NE_DATE(EN,ENO,param_count,op1, op2)	pNE_DATE(EN,ENO,&(op1),&(op2))
#define	NE__BOOL__DATE(EN,ENO,param_count,op1, op2)	pNE_DATE(EN,ENO,&(op1),&(op2))

inline BOOL pNE_TOD(EN_ENO_PARAMS TOD *op1, TOD *op2);
#define	NE_TOD(EN,ENO,param_count,op1, op2)	pNE_TOD(EN,ENO,&(op1),&(op2))
#define	NE__BOOL__TOD(EN,ENO,param_count,op1, op2)	pNE_TOD(EN,ENO,&(op1),&(op2))

inline BOOL pNE_DT(EN_ENO_PARAMS DT *op1, DT *op2);
#define	NE_DT(EN,ENO,param_count,op1, op2)	pNE_DT(EN,ENO,&(op1),&(op2))
#define	NE__BOOL__DT(EN,ENO,param_count,op1, op2)	pNE_DT(EN,ENO,&(op1),&(op2))

inline BOOL pNE_TIME(EN_ENO_PARAMS TIME *op1, TIME *op2);
#define	NE_TIME(EN,ENO,param_count,op1, op2)	pNE_TIME(EN,ENO,&(op1),&(op2))
#define	NE__BOOL__TIME(EN,ENO,param_count,op1, op2)	pNE_TIME(EN,ENO,&(op1),&(op2))

/* Comparison for string data types */	
//__ne_string(NE_STRING, STRING) /* The explicitly typed standard functions */
//__ne_string(NE__BOOL__STRING__STRING, STRING) /* Overloaded function */






/*********************************************/  
/*********************************************/  
/*  2.5.1.5.5   Character string  Functions  */
/*********************************************/  
/*********************************************/  

/*************************************/
/***           Table 29            ***/
/***  Character string  Functions  ***/
/*************************************/

/* We do not delcare explcitly typed versions of the functions in table 29.
 * See note above regarding explicitly typed functions for more details.
 */
 



    /***************/
    /*     LEN     */
    /***************/
 //inline __strlen_t __len(STRING IN);

/* A function, with 1 input paramter, implementing a generic OPERATION */
#define __genoper_1p_(fname,ret_TYPENAME, par_TYPENAME, OPERATION) \
 inline ret_TYPENAME fname(EN_ENO_PARAMS par_TYPENAME par1);

#define __iec_(TYPENAME) __genoper_1p_(LEN__##TYPENAME##__STRING, TYPENAME, STRING, __len)
//__ANY_INT(__iec_)
#undef __iec_


    /****************/
    /*     LEFT     */
    /****************/

#define __left(TYPENAME) \
 inline STRING LEFT__STRING__STRING__##TYPENAME(EN_ENO_PARAMS STRING IN, TYPENAME L);
//__ANY_INT(__left)


    /*****************/
    /*     RIGHT     */
    /*****************/

#define __right(TYPENAME) \
 inline STRING RIGHT__STRING__STRING__##TYPENAME(EN_ENO_PARAMS STRING IN, TYPENAME L);
//__ANY_INT(__right)


    /***************/
    /*     MID     */
    /***************/

#define __mid(TYPENAME) \
 inline STRING MID__STRING__STRING__##TYPENAME##__##TYPENAME(EN_ENO_PARAMS STRING IN, TYPENAME L, TYPENAME P);
//__ANY_INT(__mid)


    /******************/
    /*     CONCAT     */
    /******************/

//inline STRING CONCAT(EN_ENO_PARAMS UINT param_count, ...);

    /******************/
    /*     INSERT     */
    /******************/

//inline STRING __insert(STRING IN1, STRING IN2, __strlen_t P);

#define __iec_(TYPENAME) \
 inline STRING INSERT__STRING__STRING__STRING__##TYPENAME(EN_ENO_PARAMS STRING str1, STRING str2, TYPENAME P);
//__ANY_INT(__iec_)
#undef __iec_


    /******************/
    /*     DELETE     */
    /******************/

//inline STRING __delete(STRING IN, __strlen_t L, __strlen_t P);

#define __iec_(TYPENAME) \
 inline STRING DELETE__STRING__STRING__##TYPENAME##__##TYPENAME(EN_ENO_PARAMS STRING str, TYPENAME L, TYPENAME P);
//__ANY_INT(__iec_)
#undef __iec_


    /*******************/
    /*     REPLACE     */
    /*******************/

 inline STRING __replace(STRING IN1, STRING IN2, __strlen_t L, __strlen_t P);

#define __iec_(TYPENAME) \
 inline STRING REPLACE__STRING__STRING__STRING__##TYPENAME##__##TYPENAME(EN_ENO_PARAMS STRING str1, STRING str2, TYPENAME L, TYPENAME P);
// __ANY_INT(__iec_)
#undef __iec_

    /****************/
    /*     FIND     */
    /****************/

//inline __strlen_t __pfind(STRING* IN1, STRING* IN2);

#define __iec_(TYPENAME) \
 inline TYPENAME FIND__##TYPENAME##__STRING__STRING(EN_ENO_PARAMS STRING str1, STRING str2);
//__ANY_INT(__iec_)
#undef __iec_


/*********************************************/  
/*********************************************/  
/*  2.5.1.5.6  Functions of time data types  */
/*********************************************/  
/*********************************************/  

/**************************************/
/***           Table 30             ***/
/***  Functions of time data types  ***/
/**************************************/

inline TIME* pADD_TIME(EN_ENO_PARAMS TIME *IN1, TIME *IN2);
#define ADD_TIME(EN,ENO,IN1,IN2) *pADD_TIME(EN,ENO,&(IN1),&(IN2))
#define ADD__TIME__TIME__TIME	ADD_TIME /* overloaded version of ADD(TIME, TIME) */

inline TOD* pADD_TOD_TIME(EN_ENO_PARAMS TOD *IN1, TIME *IN2);
#define ADD_TOD_TIME(EN,ENO,IN1,IN2) *pADD_TOD_TIME(EN,ENO,&(IN1),&(IN2))
#define ADD__TOD__TOD__TIME	ADD_TOD_TIME /* overloaded version of ADD(TOD, TIME) */

inline DT* pADD_DT_TIME(EN_ENO_PARAMS DT *IN1, TIME *IN2);
#define ADD_DT_TIME(EN,ENO,IN1,IN2) *pADD_DT_TIME(EN,ENO,&(IN1),&(IN2))
#define ADD__DT__DT__TIME	ADD_DT_TIME /* overloaded version of ADD(DT, TIME) */

inline TIME* pSUB_TIME(EN_ENO_PARAMS TIME *IN1, TIME *IN2);
#define SUB_TIME(EN,ENO,IN1,IN2) *pSUB_TIME(EN,ENO,&(IN1),&(IN2))
#define SUB__TIME__TIME__TIME	SUB_TIME /* overloaded version of SUB(TIME, TIME) */

inline TIME* pSUB_DATE_DATE(EN_ENO_PARAMS DATE *IN1, DATE *IN2);
#define SUB_DATE_DATE(EN,ENO,IN1,IN2) *pSUB_DATE_DATE(EN,ENO,&(IN1),&(IN2))
#define SUB__TIME__DATE__DATE	SUB_DATE_DATE /* overloaded version of SUB(DATE, DATE) */

inline TOD* pSUB_TOD_TIME(EN_ENO_PARAMS TOD *IN1, TIME *IN2);
#define SUB_TOD_TIME(EN,ENO,IN1,IN2) *pSUB_TOD_TIME(EN,ENO,&(IN1),&(IN2))
#define SUB__TOD__TOD__TIME	SUB_TOD_TIME /* overloaded version of SUB(TOD, TIME) */

inline TIME* pSUB_TOD_TOD(EN_ENO_PARAMS TOD *IN1, TOD *IN2);
#define SUB_TOD_TOD(EN,ENO,IN1,IN2) *pSUB_TOD_TOD(EN,ENO,&(IN1),&(IN2))
#define SUB__TIME__TOD__TOD	SUB_TOD_TOD /* overloaded version of SUB(TOD, TOD) */

inline DT* pSUB_DT_TIME(EN_ENO_PARAMS DT *IN1, TIME *IN2);
#define SUB_DT_TIME(EN,ENO,IN1,IN2) *pSUB_DT_TIME(EN,ENO,&(IN1),&(IN2))
#define SUB__DT__DT__TIME	SUB_DT_TIME /* overloaded version of SUB(DT, TIME) */

inline TIME* pSUB_DT_DT(EN_ENO_PARAMS DT *IN1, DT *IN2);
#define SUB_DT_DT(EN,ENO,IN1,IN2) *pSUB_DT_DT(EN,ENO,&(IN1),&(IN2))
#define SUB__TIME__DT__DT	SUB_DT_DT /* overloaded version of SUB(DT, DT) */

/***  MULTIME_TYPENAME  ***/
#define __iec_(TYPENAME)\
 inline TIME* pMULTIME_##TYPENAME(EN_ENO_PARAMS TIME *IN1, TYPENAME IN2);
__ANY_NUM(__iec_)
#undef __iec_

/***  MULTIME  ***/
#define MULTIME_REAL(EN,ENO,IN1,IN2) *pMULTIME_REAL(EN,ENO,&(IN1),IN2)
#define MULTIME__TIME__TIME__REAL MULTIME_REAL

#define MULTIME_LREAL(EN,ENO,IN1,IN2) *pMULTIME_LREAL(EN,ENO,&(IN1),IN2)
#define MULTIME__TIME__TIME__LREAL MULTIME_LREAL

#define MULTIME_SINT(EN,ENO,IN1,IN2) *pMULTIME_SINT(EN,ENO,&(IN1),IN2)
#define MULTIME__TIME__TIME__SINT MULTIME_SINT

#define MULTIME_INT(EN,ENO,IN1,IN2) *pMULTIME_INT(EN,ENO,&(IN1),IN2)
#define MULTIME__TIME__TIME__INT MULTIME_INT

#define MULTIME_DINT(EN,ENO,IN1,IN2) *pMULTIME_DINT(EN,ENO,&(IN1),IN2)
#define MULTIME__TIME__TIME__DINT MULTIME_DINT

#define MULTIME_LINT(EN,ENO,IN1,IN2) *pMULTIME_LINT(EN,ENO,&(IN1),IN2)
#define MULTIME__TIME__TIME__LINT MULTIME_LINT

#define MULTIME_USINT(EN,ENO,IN1,IN2) *pMULTIME_USINT(EN,ENO,&(IN1),IN2)
#define MULTIME__TIME__TIME__USINT MULTIME_USINT

#define MULTIME_UINT(EN,ENO,IN1,IN2) *pMULTIME_UINT(EN,ENO,&(IN1),IN2)
#define MULTIME__TIME__TIME__UINT MULTIME_UINT

#define MULTIME_UDINT(EN,ENO,IN1,IN2) *pMULTIME_UDINT(EN,ENO,&(IN1),IN2)
#define MULTIME__TIME__TIME__UDINT MULTIME_UDINT

#define MULTIME_ULINT(EN,ENO,IN1,IN2) *pMULTIME_ULINT(EN,ENO,&(IN1),IN2)
#define MULTIME__TIME__TIME__ULINT MULTIME_ULINT

/***  MUL  ***/
#define MUL__TIME__TIME__REAL MULTIME_REAL
#define MUL__TIME__TIME__LREAL MULTIME_LREAL
#define MUL__TIME__TIME__SINT MULTIME_SINT
#define MUL__TIME__TIME__INT MULTIME_INT
#define MUL__TIME__TIME__DINT MULTIME_DINT
#define MUL__TIME__TIME__LINT MULTIME_LINT
#define MUL__TIME__TIME__USINT MULTIME_USINT
#define MUL__TIME__TIME__UINT MULTIME_UINT
#define MUL__TIME__TIME__UDINT MULTIME_UDINT
#define MUL__TIME__TIME__ULINT MULTIME_ULINT

/***  DIVTIME_TYPENAME  ***/
#define __iec_(TYPENAME)\
 inline TIME* pDIVTIME_##TYPENAME(EN_ENO_PARAMS TIME *IN1, TYPENAME IN2);
__ANY_NUM(__iec_)
#undef __iec_

/***  DIVTIME  ***/
#define DIVTIME_REAL(EN,ENO,IN1,IN2) *pDIVTIME_REAL(EN,ENO,&(IN1),IN2)
#define DIVTIME__TIME__TIME__REAL DIVTIME_REAL

#define DIVTIME_LREAL(EN,ENO,IN1,IN2) *pDIVTIME_LREAL(EN,ENO,&(IN1),IN2)
#define DIVTIME__TIME__TIME__LREAL DIVTIME_LREAL

#define DIVTIME_SINT(EN,ENO,IN1,IN2) *pDIVTIME_SINT(EN,ENO,&(IN1),IN2)
#define DIVTIME__TIME__TIME__SINT DIVTIME_SINT

#define DIVTIME_INT(EN,ENO,IN1,IN2) *pDIVTIME_INT(EN,ENO,&(IN1),IN2)
#define DIVTIME__TIME__TIME__INT DIVTIME_INT

#define DIVTIME_DINT(EN,ENO,IN1,IN2) *pDIVTIME_DINT(EN,ENO,&(IN1),IN2)
#define DIVTIME__TIME__TIME__DINT DIVTIME_DINT

#define DIVTIME_LINT(EN,ENO,IN1,IN2) *pDIVTIME_LINT(EN,ENO,&(IN1),IN2)
#define DIVTIME__TIME__TIME__LINT DIVTIME_LINT

#define DIVTIME_USINT(EN,ENO,IN1,IN2) *pDIVTIME_USINT(EN,ENO,&(IN1),IN2)
#define DIVTIME__TIME__TIME__USINT DIVTIME_USINT

#define DIVTIME_UINT(EN,ENO,IN1,IN2) *pDIVTIME_UINT(EN,ENO,&(IN1),IN2)
#define DIVTIME__TIME__TIME__UINT DIVTIME_UINT

#define DIVTIME_UDINT(EN,ENO,IN1,IN2) *pDIVTIME_UDINT(EN,ENO,&(IN1),IN2)
#define DIVTIME__TIME__TIME__UDINT DIVTIME_UDINT

#define DIVTIME_ULINT(EN,ENO,IN1,IN2) *pDIVTIME_ULINT(EN,ENO,&(IN1),IN2)
#define DIVTIME__TIME__TIME__ULINT DIVTIME_ULINT

/***  DIV  ***/
#define DIV__TIME__TIME__REAL DIVTIME_REAL
#define DIV__TIME__TIME__LREAL DIVTIME_LREAL
#define DIV__TIME__TIME__SINT DIVTIME_SINT
#define DIV__TIME__TIME__INT DIVTIME_INT
#define DIV__TIME__TIME__DINT DIVTIME_DINT
#define DIV__TIME__TIME__LINT DIVTIME_LINT
#define DIV__TIME__TIME__USINT DIVTIME_USINT
#define DIV__TIME__TIME__UINT DIVTIME_UINT
#define DIV__TIME__TIME__UDINT DIVTIME_UDINT
#define DIV__TIME__TIME__ULINT DIVTIME_ULINT

/*** CONCAT_DATE_TOD ***/
inline DT* pCONCAT_DATE_TOD(EN_ENO_PARAMS DATE *IN1, TOD *IN2);
#define CONCAT_DATE_TOD(EN,ENO,IN1,IN2) *pCONCAT_DATE_TOD(EN,ENO,&(IN1),&(IN2))


/****************************************************/  
/****************************************************/  
/*  2.5.1.5.6   Functions of enumerated data types  */
/****************************************************/  
/****************************************************/  

/********************************************/
/***              Table 31                ***/
/***  Functions of enumerated data types  ***/
/********************************************/

/* Do we support this? */








#endif /* _IEC_STD_FUNCTIONS_H */
